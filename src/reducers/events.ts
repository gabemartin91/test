import {
  createAsyncThunk,
  createSlice,
  PayloadAction,
  Reducer,
} from "@reduxjs/toolkit";
import { getEventDataFromMockedApi } from "../api";
import { DeviceEvent } from "../types";
import { RootState } from "./store";

export interface DeviceEventsState {
  ids: number[];
  entities: { [id: number]: DeviceEvent };
  selectedId?: number;
  status?: "pending" | "fulfilled" | "rejected";
}

const initialState: DeviceEventsState = {
  ids: [],
  entities: [],
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(fetchDeviceEvents())`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const fetchDeviceEvents = createAsyncThunk(
  "fetchDeviceEvents",
  async (): Promise<DeviceEvent[]> => {
    try {
      return await getEventDataFromMockedApi();
    } catch (e) {
      return Promise.reject(e);
    }
  }
);

export const deviceEvents = createSlice({
  name: "deviceEvents",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    clickDeviceEvent(state, action: PayloadAction<number>) {
      state.selectedId = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchDeviceEvents.pending, (state) => {
        state.status = "pending";
      })
      .addCase(fetchDeviceEvents.fulfilled, (state, action) => {
        state.status = "fulfilled";
        const initializer: DeviceEventsState = {
          ids: [],
          entities: {},
        };
        const nextState = action.payload.reduce((accumulator, deviceEvent) => {
          return {
            ...accumulator,
            ids: [...accumulator.ids, deviceEvent.id],
            entities: {
              ...accumulator.entities,
              [deviceEvent.id]: {
                ...deviceEvent,
              },
            },
          };
        }, initializer);
        state.ids = nextState.ids;
        state.entities = nextState.entities;
      })
      .addCase(fetchDeviceEvents.rejected, (state) => {
        state.status = "rejected";
      });
  },
});

export const { clickDeviceEvent } = deviceEvents.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.deviceEvents.selectedId)`
export function getSelectedEventId(state: RootState): number | undefined {
  return state.deviceEvents.selectedId;
}

export const getAllDeviceEvents = (state: RootState): DeviceEvent[] => {
  return state.deviceEvents.ids.map((id) => {
    const event = state.deviceEvents.entities[id];
    if (typeof event === "undefined") {
      console.error(`No event for id: ${id}`);
    }
    return event;
  });
};

const deviceEventsReducer: Reducer<DeviceEventsState> = deviceEvents.reducer;
export default deviceEventsReducer;
